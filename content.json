{"posts":[{"title":"Hello world!","text":"花了数个小时，终于建立起了专属于我的个人网站。 先是下载了一个名为 Node.js 的东西，接着用其包管理器 npm 下载了 hexo，然后又是一系列包的安装……第二天才开始着手主题的配置，一个名为 icarus 的主题最终被我选中，又是一系列的配置…… hexo 的部署过程令我迷惑，它替我完成了 git 的推送，但是我的分支管理好像出了亿点问题。到现在本地还有4000+个挂起的更改，然而hexo d命令依然能推送更改，并且 github pages 的显示效果与本地预览一模一样。以往习惯的add、commit和push工作流现在却换为了这样一套模式：hexo g，hexo s，hexo clean和hexo d，好在很快便适应了。 第四天又花了点时间治理一下混乱的版本控制，未果。我已经受够繁文缛节了，直接git push origin --force --all强制推送。现在本地必要文件全放在远端main分支，hexo d生成文件则推送到gh-pages分支。推送后发现hexo还会自动创建很多远程分支来提示我更新package.json和package-lock.json中的依赖项版本，甚至已经pull requests，在我手动合并后还能自动删除分支，这些都是一个名为Dependabot的自动化管理服务做的。合并，合并，通通合并~ 不过，以后应该写点啥呢？","link":"/2023/07/20/hello-world/"},{"title":"回溯法求解数独","text":"问题描述昨晚，朋友问了一个关于求解数独的问题。ta称其所用回溯算法虽能成功求解，但耗时颇多，而参考B站算法只需2s。我询问ta是不是没有及时剪枝或者用于判断数独的函数太慢。此时的我还只是上数据与结构课时听了回溯法这一算法的概念，从未真正用过，不过事情的结果证明我所提及的两个问题在代码中都有出现。 问题简单概括，就是给定一个数独矩阵，要求给出一组解，需使用matlab完成。给出问题框架如下： 12345678910111213141516F =[NaN 2 NaN NaN 3 NaN NaN 4 NaN; 6 NaN NaN NaN NaN NaN NaN NaN 3; NaN NaN 4 NaN NaN NaN 5 NaN NaN; NaN NaN NaN 8 NaN 6 NaN NaN NaN; 8 NaN NaN NaN 1 NaN NaN NaN 6; NaN NaN NaN 7 NaN 5 NaN NaN NaN; NaN NaN 7 NaN NaN NaN 6 NaN NaN; 4 NaN NaN NaN NaN NaN NaN NaN 8; NaN 3 NaN NaN 4 NaN NaN 2 NaN];ticres = sudoku_solve(F,1);elapsedTime = toc;disp(res);disp(['代码执行时间: ', num2str(elapsedTime), '秒']); 漫长的debug程序不能及时停止一开始的解法如下：（此前已经弃用了unique()和setdiff()函数，效率大幅提升） 12345678910111213141516171819202122function sudoku_solve(matrix,id) if id&gt;81 disp(matrix); return; else row = floor((id-1)/9)+1; col = mod((id-1),9)+1; gong = matrix(3*floor((row-1)/3)+1:3*floor((row-1)/3)+3, 3*floor((col-1)/3)+1:3*floor((col-1)/3)+3); if ~isnan(matrix(row,col)) sudoku_solve(matrix,id+1); else for num = 1:9 if (~ismember(num,matrix(row, :))) ... &amp;&amp; (~ismember(num,matrix(:, col)')) ... &amp;&amp; (~ismember(num,gong(:)')) matrix(row,col) = num; sudoku_solve(matrix,id +1); end end end endend 这里的代码就是朋友参考的B站的解法，在我电脑上求解原数独问题大致需要10s。但是它有一个bug：求解出来的数独的第一格填的数字是9，于是我们面向结果编程，将for循环改为for num = 9:-1:1，发现确实能很快输出正确结果，但是程序在输出结果后还会接续运行，最终实际运行时间与改之前无异。 面对这样的bug，我首先想到的是for循环中得到结果后没有及时返回（对应之前“没有及时剪枝”），所以在for循环中加入了这样的代码： 123if id == 81 returnend 只能说我的直觉是准的，但是对我的代码水平来说还是过于超前 : ) 运行结果表明这样修改后程序效率没有提升，我顿时陷入迷茫。其实这个判断语句没有起到作用，得到结果后，多层调用的递归函数一层层返回，每一层的id值随深度依次增加，最深层是82，表明得到结果，然后返回到倒数第二层，此时id为81，判断语句为真，继续返回（还跳出了for循环）；但是倒数第三层以及后续的id都小于81，所以我新写的代码就失效了。所以这里也能看出出现bug的原因：正确结果没有及时返回，for循环体继续执行。 需要返回值前一个bug还未解决，朋友提出了新需求，希望这个函数有返回值，于是修改代码如下： 12345678910111213141516171819202122function result = sudoku_solve(matrix,id) if id&gt;81 result = matrix; return; else row = floor((id-1)/9)+1; col = mod((id-1),9)+1; gong = matrix(3*floor((row-1)/3)+1:3*floor((row-1)/3)+3, 3*floor((col-1)/3)+1:3*floor((col-1)/3)+3); if ~isnan(matrix(row,col)) result = sudoku_solve(matrix,id+1); else for num = 1:9 if (~ismember(num,matrix(row, :))) ... &amp;&amp; (~ismember(num,matrix(:, col)')) ... &amp;&amp; (~ismember(num,gong(:)')) matrix(row,col) = num; result = sudoku_solve(matrix,id +1); end end end endend 但是这样的代码运行会报错，原因在于不是每个分支都有return值。具体问题出现在for循环中的if语句，在判断为真的情况下，显然result是有赋值的；但是如果判断为假就会发生rseult未被定义的问题，该分支就没有返回值了。所以解决问题就是，在函数体开头就写上rseult = []。 然后，朋友提出了解决第一个bug的方法：在result = sudoku_solve(matrix,id +1);下添加如下代码： 123if ~isempty(rseult) return;end 这一改动很轻松地解决了此前程序算出正确结果后没有及时返回的问题，不会执行多余的运算，因此效率得到提升，在for num = 9:-1:1的情况下仅需2s左右。 运行时间还是太长程序的运行时间太依赖与数独的解的情况，正如之前所说，这个数独的第一格填的是9，所以当我们使用for num = 9:-1:1时效率会比较高，直接跳过了回溯中的好几次漫长搜索过程。如果继续使用for num = 1:9的话，运行时间还是长达8s左右。 第二天上午（今早），朋友再次与我讨论回溯法的细节，我便试图优化程序以进一步提升效率。最终，我发现，matlab函数ismember()效率很慢。我修改了代码的一些结构，重写如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344function [result] = sudoku_solve(matrix,id) result = []; if id&gt;81 result = matrix; return end row = floor((id-1)/9)+1; col = mod((id-1),9)+1; if ~isnan(matrix(row,col)) result = sudoku_solve(matrix,id+1); return end g_row = 3*floor((row-1)/3); g_col = 3*floor((col-1)/3); gong = matrix(g_row+1:g_row+3, g_col+1:g_col+3); for num = 1:9 if (~hasmember(num,matrix(row, :))) ... &amp;&amp; (~hasmember(num,gong(:)')) ... &amp;&amp; (~hasmember(num,matrix(:, col)')) matrix(row,col) = num; result = sudoku_solve(matrix,id +1); if ~isempty(result) return end end end endfunction res = hasmember(num, array) res = false; for i=1:9 if array(i) == num res = true; return end endend 这一改动使得1:9耗时2秒，9:-1:1仅需0.6秒！ 一点心得前前后后大概花了3个多小时解决这个问题，唯一体会就是matlab一点也不适合写算法。","link":"/2023/08/08/%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%B1%82%E8%A7%A3%E6%95%B0%E7%8B%AC/"}],"tags":[{"name":"回溯法","slug":"回溯法","link":"/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"}],"categories":[{"name":"啥都写","slug":"啥都写","link":"/categories/%E5%95%A5%E9%83%BD%E5%86%99/"}],"pages":[]}